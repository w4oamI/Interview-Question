깃 연동
Interview-Question.
//----------------------------------------------------------------//

★★★★★데이터베이스★★★★★

[테이블]
//---------------------------------------------------------------//.    
테이블 : 행과 열로 이루어진 데이터의 집합이다.
         RDB에서는 테이블을 릴레이션이라고도 한다.
         모든 릴레이션은 테이블이지만, 모든 테이블은 릴레이션이 아니다.
         -> 조건이 충족 되어야 한다.
            1. 모든 값을 유일한 값을 가진다.
            2. 하나의 릴레이션에는 중복되는 행이 존재해서는 안된다.
//---------------------------------------------------------------//.    

[ROW]
//---------------------------------------------------------------//.    
행 : 테이블을 구성하는 데이터의 가로로 묶은 데이터셋을 의미한다.
     행은 한 객체에 대한 정보를 가지고 있다.
     튜플 또는 레코드 라고한다.
//---------------------------------------------------------------//.    

[Colum]
//---------------------------------------------------------------//.    
열 : 테이블을 구성하는 데이터의 세로를 묶은 데이터셋을 의미한다.
     열을 구성하는 값은 같은 도메인으로 되어 있다.
     속성이라고도 한다.
//---------------------------------------------------------------//.    

[인덱스]
//---------------------------------------------------------------//.    
인덱스 : 데이터베이스 테이블의 검색속도를 향상시키기 위한 자료구조이다.

인덱스의 단점 : 인덱스를 구축하는 비용 발생.
               추가,삭세,수정 연산시 인덱스를 형성하기 위한 추가 연산이 필요하다.
//---------------------------------------------------------------//.    


[클러스터 인덱스와 넌클러스트 인덱스].
//----------------------------------------------------------------//.
클러스터 : 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이 자주 사용되는 테이블의 데이터를 디스크의 같은 위치에 저장 시키느 방법. 

-클러스터 인덱스.

하나의 테이블에 한개만 생성이 가능하다.
조회는 빠르지만, 수정 삽입 삭제는 느리다.
물리적으로 행을 재배열한다.
인덱스 페이지 용량이 넌클러스터 보다 작다.


-넌클러스터 인덱스.

하나의 테이블의 여러개 생성이 가능하다.
조회는 느리지만, 수정 삽입 삭제가 빠르다.
물리적으로 재배열을 하지 않는다.
인덱스 페이지 용량이 클러스터 인덱스 보다 크다.
//----------------------------------------------------------------//.

[rollback 과 commit]
//---------------------------------------------------------------//.    
rollback과 commit은 insert,update,delete문을 사용했을때 사용하는 쿼리문이다.
rollback은 데이터를 수행전으로 되돌리고 싶을때 사용을 한다.
commit은 쿼리문을 수행후 해당 결과에 대해 확정 하는 것이다.
//---------------------------------------------------------------//.    

[트랜잭션]
//---------------------------------------------------------------//.    
트랜잭션이란 : 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업단위
트랜잭션은 성공하려면 성공해야하고, 실패하려면 전부 실패 해야한다.
//---------------------------------------------------------------//.    

[정규화]
//---------------------------------------------------------------//.    
정규화 : 데이터의 중복을 방지하고, 무결성을 충족하기 위해 DB를 설계하는 것을 의미한다.
정규화를 하지 않으면 이상현상이 발생하는데 이를 없애고자 한다.
이상현상에는 삽입이상, 삭제이상, 삽입이상이 있다.
//---------------------------------------------------------------//.    

[스키마]
//---------------------------------------------------------------//.    
스키마 : 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
        (자료의 구조, 자료의 표현 방법, 자료 간의 관계)
 
외부 스키마 : 사용자 입장에서 정의한 논리적 구조
개념 스키마 : 조직체 전체입장에서 DB를 정의한 스키마
내부 스키마 : 어떻게 저장될지에 대한 명세
//---------------------------------------------------------------//.    

[RDBMS 와 NoSQL]
//---------------------------------------------------------------//.    
RDBMS : 정형데이터를 저장한다.
        연산이 가능하다.
        각각의 속성과 값을 가진 테이블들은 서로 관계를 맺으며 존재한다.
        데이터의 분류, 탐색, 정렬의 속도가 비교적 빠르다.
        
NoSQL : 비정형데이터를 저장한다.
        연산이 불가능하다.
        데이터와 테이블간의 관계를 정의하지 않는다.
        스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어 있지 않다.
//---------------------------------------------------------------//.    


★★★★★네트워크★★★★★

[OSI 7Layer 와 TCP/IP 4Layer]
//---------------------------------------------------------------//.    
OSI 7Layer             TCP/IP 4Layer

응용 계층
표현 계층                 응용 계층
세션 계층
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
전송 계층                 전송 계층
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
네트워크 계층             인터넷 계층
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 링크 계층         네트워크 엑세스
물리 계층                    계층
//---------------------------------------------------------------//.    

[로드 밸런싱]
//---------------------------------------------------------------//.    
로드 밸런싱 : 여러 서버에 균등하게 트래픽을 분산 시켜주는 것이다.

보통 서버에 많은 트래픽이 모여 과부하 발생되기 때문에 성능을 올리거나, 서버를 여러개 둔다.

//---------------------------------------------------------------//.    

★★★★★WEB★★★★★
[Http와 Https].
//----------------------------------------------------------------//.
어떠한 요청을 웹 브라우저가(클라이언트) 웹 서버에 무언인가 요청을 할 때 사용하는 프로토콜이다.

http.

서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜.
80번 포트를 사용하고, 클라이언트의 요청도 80번 포트로 보낸다.
Https.

Http에 데이터 암호화를 추가한 프로토콜이다.
SSL인증서를 사용한다.
433번 포트를 사용하고, 공개키 암호화를 지원한다.
SSL인증서는 사용자가 사이트에 제공하는 정보를 암호화 하고,
TLS(전송계층 보안)프로토콜을 통해서도 보안을 유지한다. TLS는 데이터 무결성을 보장하기 때문에 데이터가 도중에 수정 및 손상을 방지하고, 사용자가 사신이 의도하는 웹사이트와 통신하고 있다는 것을 입증하는 인증 기능도 제공한다.

=>Http는 보안에 취약한 반면 Https는 안전하게 데이터를 주고 받을 수 있다. 하지만 Https는 암호화와 복호화 과정이 필요하기 때문에 Https보다 속도가 느리다. (요즘은 거의 차이가 나지 않는다.) 또한 Https는 인증서를 발급하고 유지하기 위해 추가 비용이 발생한다.
//----------------------------------------------------------------//.

[Session 과 Cookie].
//---------------------------------------------------------------//.
사용이유 : HTTP프로토콜의 특징이자 약점을 보호하기 위해 사용한다.

HTTP 프로토콜의 특징.
비연결지향 : 요청하고, 응답을 한 후에 연결을 끊는 특정이 있다.
상태없음 : Connection을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는다.

=> 비연결지향이기 때문에 서버 리소스 낭비가 줄어든다는 장점이 있지만, 통신을 할때마다 새로운 커넥션을 만들어야 하기 때문에 클라이언트 쪽에서는 상태를 유지를 위해 통신 할때마다 어떤 절차를 거쳐야한다.
즉, 세션 및 쿠키가 없다면 다른 페이지로 넘어갈때마다 인증을 다시 받아야 한다.

쿠키(Cookie).
클라이언트 로컬에 저장되는 key와 value이 들어있는 작은 데이터 파일.
이름,값,만료날짜/시간,경로 정보 등이 들어있다.

-세션 쿠키 : 브라우저 메모리에 저장되므로 브라우저가 종료되면 쿠키는 사라진다.(만료 날짜/시간).
-지속 쿠키 : 파일로 저장되므로 브라우저가 종료되어도 쿠키는 남아있게 된다.(XXX 만료 날짜/시간 XXX).

세션(Sesstion).
서버에 클라이언트의 상태 정보를 저장하는 기술로 논리적인 연결을 세션이라고 한다.
웹 서버에 클라이언트의 정보를 저장하고, 클라이언트에게 구분을 위한 ID를 부여하는데 이것이 세션이다.

차이점.
저장 위치 : 쿠키는 클라이언트의 메모리 또는 파일, 세션은 서버 메모리에 저장된다.
보안 : 쿠키는 로컬에 저장되기 때문에 변조, 탈취 위험이 있지만, 세션은 서버에 있어 비교적 안전하다.

//---------------------------------------------------------------//.

[MVC패턴].
//---------------------------------------------------------------//.
사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.

Model - 백그라운드에서 동작하는 로직을 처리한다. (데이터를 가진 객체, 파라미터로 주로 쓰인다.) , DB의 테이블과 대응하는 경우가 많다.
View - 사용자가 보게 될 결과 화면을 출력한다. (HTML,CSS,Javascsript를 모아둔 컨테이너).
Controller - 사용자의 입력처리와 흐름 제어를 담당한다. (사용자가 접근한 URL에 따라서 사용자의 요청사항을 파악 후, 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영하여 사용자에게 알려준다.) MVC 패턴 특징 - 전체적인 구조에 관련된 패턴으로 도메인(비즈니스)과 UI로직을 분리하여 유지보수를 독립적으로 수행할 수 있게 한다.
//---------------------------------------------------------------//.    

[TCP와UDP]
//---------------------------------------------------------------//.    
TCP는 연결형 서비스를 지원하는 전송계층의 프로토콜이다. 호스트간 신뢰성 있는 통신을 하고, 흐름제어 및 혼잡제어를 제공한다.
UDP는 비연결 서비스를 지원하는 전송계층의 프로토콜이다. 신뢰성이 낮고, 속도는 빠르다. 또한 handshaking과 같은 설정은 필요없다.
//---------------------------------------------------------------//.        

[handshaking]
//---------------------------------------------------------------//.    
handshaking은 크게 3-way와 4-way가 있다.

3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면, 
4-Way handshake는 세션을 종료하기 위해 수행되는 절차입니다.

//---------------------------------------------------------------//.    

[RESTful API]
//---------------------------------------------------------------//.    
HTTP통신에서 CRUD요청을 리소스와 메소드로 표현하여 특정한 형태로 전달하는 방식이다.
리소스 : 자원 , URI
메소드 : 요청방식으로 GET 또는 POST등
Representation of Resource: 자원의 형태로 json 또는 xml등
//---------------------------------------------------------------//.    

[GET 과 POST]
//---------------------------------------------------------------//.   
GET과 POST는 클라이언트가 서버에 요청을 보내는 방법으로 HTTP Method의 방식이다.
GET : -GET요청은 파라미터에 정보가 담겨있기 때문에 중요한 정보는 보내면 안된다.
       ex) www.github.com/wami?password=12345&Id=wami  <- 실존하지 않는 주소지만 ?부터 정보가 담겨있다.
      -요청의 길이가 제한이 되어있다. (브라우저마다 제한이 다르다.)\
      -데이터를 요청할 때만 사용한다.
      -캐싱이 가능하다.
 
 POST : -POST요청은 BODY에 전송하고자 하는 데이터를 담아서 서버로 보낸다.
        -길이 제한이 없다.
        -캐시되지 않는다.
        -데이터가 외부에 드러나 있지 않아 보안에 좋다.
        
이외에도 다른 메소드도 존재한다.
그의 대한 설명은 아래 참고
https://alka-loid.tistory.com/63
//---------------------------------------------------------------//.    


[HTTP 와 SOCKET]
//---------------------------------------------------------------//.    
HTTP : 단방향적 통신으로, 클라이언트의 요청이 있을때 서버가 응답을 한다.
       그후 바로 연결을 종료한다. 즉, 실시간 연결이 아닌 필요할때 SERVER로 접근하는 컨텐츠 위주의 데이터를 사용할때 용이하다.

SOCKET : 양방향 통신으로 클라이언트와 서버가 특정 PORT를 통해 실시간으로 통신을 한다.
         양방향이기 때문에 server또한 client에게 요청을 보낼수 있다.
//---------------------------------------------------------------//.    


[웹 통신의 흐름]
//---------------------------------------------------------------//.    
사용자가 브라우저에 도메인 이름을 입력한다. 예로, www.naver.com
DNS서버에서 사용자가 입력한 domain name을 검색하여 맵핑하는 ip주소를 찾는다.
그후 ip주소는 HTTP프로토콜을 이용해 HTTP요청 메세지를 생성하여 TCP프로토콜을 사용해
인터넷을 거쳐 해당 ip주소의 컴퓨터(서버)로 전송이된다.
서버는 요청을 승인한후 해당 메세지를 받아 응답 메세지를 전송한다.
해당 메세지는 http프로토콜을 사용하여 웹페이지 데이터로 변환되어 웹 브라우저에 출력되어 사용자가 볼수 있게 된다.

그럼 OSI 7Layer로 설명을 해보면
브라우저가 URL에 적힌 값을 파싱하여 HTTP요청 메세지를 만들어 OS에 전송 요청을 한다. 이때 DOMAIN은 www.naver.com과 같은 표현이기 때문에
보낼수가 없어 DNS LOOKUP을 수행하여 IP를 찾는다. 대게 DNS lookup은 루트 도메인 서버 -> 서브 도메인 서버 순으로 찾는다. 
www.naver.com과 같은 경우에는 .com이 루트 도메인 서버가 된다.
크롬 브라우저는 브라우저 -> hosts파일 -> dns cache순으로 도메인에 매칭되는 ip를 찾는다.
ip를 찾고 난후 해당 요청은 os에 내장되어 있는 네트워크 제어용 소프트웨어에 의하여 패킷에 담기고 패킷에 제어정보를 담아 LAN어댑터에 전송한다.
LAN어댑터는 이를 전기신호로 바꾸어 송출한다.
응용 계층->표현 계층->세션 계층->전송 계층->네트워크 계층->데이터링크 계층->물리계층 순으로 정리가 된것이다.

송출된 패킷은 스위칭 허브등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달이 되고 인터넷으로 이동을 한다.
그후 액세스 회선을 통해 통신사용 라우터로 운반되고 인터넷의 핵심부로 이동이 된다.
그리고 고속 라우터를 이동하면서 최종 목적지 까지 패킷이 이동된다.

목적지 까지 도착한 패킷은 LAN에 도착하여 방화벽이 패킷을 유효성 검사를 하고 캐시서버로 보내서 웹 서버에 갈수 있는지 확인한다.
웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출 하여 메세지를 복원하고 웹 서버 어플리케이션에 넘기게 된다. 
해당 메세지를 확인하여 응답 메세지를 작성하여 다시 클라이언트로 위와 같은 과정을 거친다.
물리 계층->데이터 링크 계층->네트워크 계층->전송 계층->세션 계층->표현 계층->응용 계층 순으로 정리가 된것 이다.
//---------------------------------------------------------------//.    

[캐시]
//---------------------------------------------------------------//.    
캐시 : 자주 사용하는 값이나 데이터를 미리 복사해 놓는 임시 저장소.
      저장 공간이 작고, 빠르지만 비용이 비싸다.
      
사용 용도 : 반복적으로 동일한 결과를 반환할때 사용한다. (이미지 및 썸네일)
          데이터의 접근 시간이 오래 걸릴 경우(서버의 균일한 API데이터)
//---------------------------------------------------------------//.    


[생명주기].
//---------------------------------------------------------------//.
*순간. 멍해져 간단한 질문이었지만, 대답을 하지 못했다.
-SDLC는 개발과 유지보수 등에 필요한 작업들을 체계적으로 정리한 방법론이다.

※생명주기 순서※.
계획 -> 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수.
//---------------------------------------------------------------//.

[Opencv를 이용하면서 CUDA를 사용한 방법].
//---------------------------------------------------------------//.
*이부분도 대답을 제대로 하지 못했다. cuDNN이 갑자기 생각이 나지 않았다..
*모든것이 끝나고 생각이 났다.. 아래 대답은 개인적인 대답이기 때문에 자세한건 더 공부를 해야한다.
*개인적인 대답이지만, 해당 방법이 정확하다.

사용방법은 되게 간단하다. (사용은 편하지만 사용을 하기 이전 환경설정 하는것이 되게 힘들다.).
일단 NVIDIA그래픽에 맞는 CUDA를 설치하였다.
Tensorflow를 사용할 예정이 었기 때문에 Tensorflow에 호환이 되는 Cuda,cuDNN을 설치하고,
이어서 cmake를 이용하여 opencv빌드 옵션을 설정하여 pycham에서 opencv빌드를 진행하였다.

＃cmake : 빌드 도구로 플렛폼에 독집적인 환경을 제공하고, 컴파일 과정을 제어할수 있도록 하는 크로스플렛폼이다.
＃cuDNN : 딥러닝연산을고려하는 하드웨어가 나오면 그것을 뒷바침해주는 딥러닝 기반의 소프프웨어있어야 하는데, cuDNN은 그러한 라이브러리이다.
//---------------------------------------------------------------//.

[CUDA(GPU)에서 병렬 처리하는 방법].
//---------------------------------------------------------------//.
*프로젝트 완성에 급급하여 제대로 공부를 못한것이 실수였다.
*이제는 한번 공부하는 내용은 100%는 아니더라도 이해와 숙지가 필요할것 같다.

CUDA는 C/C++언어로 병렬계산에 필요한 기능을 제공해주는, NVIDIA에서 제공하는 소프트웨어이다.

CPU와 GPU의 기본적인 차이를 우선 알아보아야 한다.

GPU는 CPU와는 달리 코어가 아주 많다.
CPU는 복잡한 계산을 빠르게 처리하지만 모두 직렬로 처리한다.
GPU는 간단한 계산을 빠르게 처리할 수 있고, 많은 연산을 병렬로 동시에 처리한다.
위를 풀면 CPU는 시스템 자원을 제어하고, 복잡한 명령을 처리하기 때문에 다양한 구성요소가 존재하지만, GPU는 그래픽처리를 위해 만들어진 장치이기 때문에.
단순한 연산을 고속으로 처리가 가능했다. 그렇기 때문에 GPU는 단독으로 시스템 자원을 활용 할수가 없어, CPU의 제어가 필요하다.

그럼 이제 병렬처리하는 방법을 알아보자.

병렬처리할 데이터를 MAIN MEMORY에서 GPU MEMORY로 이동을 시킨다.
CPU는 GPU에게 GPU MEMORY에 있는 데이터를 가지고 연산을 하라고 제어(명령)한다.
GPU는 CPU가 명령령한 연산처리를 병렬로 수행한다.
GPU가 작업을 마치며녀 GPU MEMORY에 결과를 저장하고, 다시 MAIN MEMORY에 결과를 업로드한다.
마지막으로 CPU가 MAIN MEMORY에 접근해 해당 결과물을 이용하여 작업을 마무리한다.
//---------------------------------------------------------------//.


[딥러닝 GD 와 SGD]
//---------------------------------------------------------------//.
*이부분은 예전에 들어는 봤으나, 제대로 학습이 안된 부분이어서 대답을 하지 못했다.

GD와SGD를 알아보기 전에 이것이 무엇인지 알아야 한다.
기존 뉴럴 네트워크는 weight parameter를 최적화(optimize)하기 위해 GD방법을 사용하였다.
즉, 위의 GD와 SGD는 옵티마이저 종류중 하나이다.
GD(gradient Descent)

모든 자료를 다 검토하여 내 위치의 산기울기를 계산하여 방향을 찾는다.(full batch)
한번에 모든 Data set을 Training을 한다.
SGD(Stochastic Gradient Descent)

전부 다 봐야하는 한걸음(GD)은 너무 오래 걸려 조금만 보고 빨리 판단 한다.(mini-batch)
같은 시간에 더 많이 간다.
한번 볼때 일부 Data Set을 보고, 일부만 Training한다.
//---------------------------------------------------------------//.


[CUDA스레드와 일반 스레드 차이]
//---------------------------------------------------------------//.
기본적으로 GPU와 CPU의 코어는 다른 구조를 가지고 있다. GPU는 코어갯수 * 코어 클락으로 이루어져 있다.

CPU는 멀티 코어를 구성하는 전체 요소로, CPU에서 하나의 칩당 멀티 코어로 4~12개 정도의 코어를 가지고 있다.

GPU는 구성요소를 멀티 프로세서 라고 한다. 그 구성요소중 계산 유닛이 존재하는데, 그것을 GPU의 코어 라고한다.
GPU는 하나의 칩당 최대 15개의 멀티 프로세서를 가지고 있고, 이 멀티 프로세서 안에는 192개의 코어(계산 유닛)을 가지고 있다.
그렇기 때문에 15 * 192인 2880개의 코어를 가지고 있다. //---------------------------------------------------------------//.

[메모리 구조]
//---------------------------------------------------------------//.
메모리 구조에 크게 4가지 영역이 존재한다.

코드(code) 영역
데이터(data) 영역
스택(stack) 영역
힙(heep) 영역
첫번째 코드(code) 영역
실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부른다.
CPU는 코드 영역에 저장된 명령어를 하나씩 가져가 처리한다.

두번째 데이터(data) 영역
프로그램의 전역 변수와 정적(Static)변수가 저장되는 영역이다.
데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.

세번째 스택(stack) 영역
함수 호출과 관계되는 지역변수와 매개변수가 저장되는 영역이다.
LIFO방식에 따라 동작하며 메모리의 높은 주소에서 낮은 주소의 방향으로 할당 된다.

네번째 힙(heap)영역
사용자가 직접 관리하고 해야만 하는 영역이다. 사용자에 의해 동적으로 할당되고 해체된다. 그리고 낮은 주소에서 높은 주소의 방향으로 할당 된다.

한줄로 표현
코드영역: 실행할 프로그램의 코드
데이터 영역 : 전역변수, 정적 변수 
스택 영역 : 지역변수, 매개변수
힙 영역 : 사용자의 동적 할당
//---------------------------------------------------------------//.


★★★★★언어★★★★★

[C와 JAVA]
//---------------------------------------------------------------//.    
C와 JAVA의 가장 큰 차이는 절차지향인과 객체지향이라는 것이다.
객체지향과 절차지향에 대한 설명은 밑에서 따로 정리할 것이다.

C는 작동방식이 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향의 언어보다 빠르게 처리된다.
또한, 유지보수가 어렵고, 사용자가 직접 메모리를 조절하여 사용해야 한다.

JAVA는 JVM위에서 작동하기 때문에 운영체제에 독립적이다.
또한, GC으로 사용하지 않는 메모리를 자동으로 정리한다.
캡슐화, 다형성, 상속등 특징이 있다.
//---------------------------------------------------------------//.    

[절차지향 과 객체지향]
//---------------------------------------------------------------//.    
절차지향은 순차적인 처리가 중요시 되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.
컴퓨터와 작업 처리 방식이 유사 하기 때문에 빠르지만, 유지보수가 어렵고, 프로그램의 실행 순서가 바뀌면 동일한 결과를 보장받기 힘들다.

객체지향은 실제 세계를 모델링 하여 소프트웨어를 개발하는 방법이다. 코드의 재사용성이 높고 절차지향보다 간편하다.
하지만 처리속도가 절차지향에 비해 느리고, 설계에 많은 시간이 들어간다.

객체지향에 3대 특성이 있다.
캡슐화 : 정보은닉의 개념이 포함되어 있고, 속성(필드)과 행위(메서드)를 하나의 클래스라는 캡슐에 묶는 것이다.
다형성 : 하나의 객체가 여러가지 형태를 가질수 있는 것을 의미한다. 오버로딩과 오버라이딩이 있다.
상속 : 상위 클래스의 특성을 하위 클래스가 물려 받는것을 말하고 하위 클래스는 필요한 속성을 확장하여 사용할 수 있다.

추가적으로 추상화가 있다.

추상화 : 추상화는 모델링이며 구첵적인 것을 상세히 하지 않고, 필요성에 의해 특성만 가지고 구성하는것을 말한다.
//---------------------------------------------------------------//.    

[오버로딩 과 오버라이딩]
//---------------------------------------------------------------//.    
오버로딩 : 같은 함수의 이름을 가지고 있지만, 매개변수 타입과 리턴타입등 특징이 다른 여러개의 서브프로그램을 생성하는 것을 말한다.
오버라이딩 : 부모 메소드에서 상속받은 메소드를 자식에서 재정의 하는것이다.
//---------------------------------------------------------------//.    

[OOP]
//---------------------------------------------------------------//.    
Object-Orient Programming의 약자이다.
즉, 객체지향형 프로그래밍을 의미하는데, 모든 데이터를 객체로 취급하여 프로그래밍을 한다.
순차적으로 동작하는 프로그래밍과는 다르게 객체와 객체의 상호작용을 통해 프로그램이 동작한다.
//---------------------------------------------------------------//.    

[객체 와 클래스]
//---------------------------------------------------------------//.    
객체 : 구현해야할 대상으로 식별이 가능한 모든 것이 객체이다.
클래스 : 객체를 만들어 내기 위한 설계도 혹은 틀
         연관되어 있는 변수와 메소드의 집합

객체를 나누는 기준?
객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.
//---------------------------------------------------------------//.    


[매개변수와 전달인자]
//---------------------------------------------------------------//.    
매개변수 즉, parameter라고 한다.
 -함수를 선언할때 사용된 변수

전달인자 즉, Argument라고 한다.
 - 함수가 호출 되었을때, 함수의 파라미터로 전달될 
//---------------------------------------------------------------//.    

[라이브러리 와 프레임워크]
//---------------------------------------------------------------//.    
라이브러리 : 활용 가능한 도구의 집합을 말한다.
            개발자가 만든 클래스에서 호출하여 사용한다.
프레임워크 : 뼈대, 기반구조로 여러 클래스나 컴포넌트로 구성이 되어있다.
            즉, 특정 문제를 해결하기 위한 클래스와 인터페이스의 집합
            
 차이점: 제어권(흐름)을 누가 가지고 있는지에 대한 차이가 있다.
         라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다쓰지만,
         프레임워크는 전체의 흐름을 스스로 가지고 있으며, 사용자는 그 안에서 코드를 짜 넣는다.
//---------------------------------------------------------------//.    

[동적 프로그래밍]
//---------------------------------------------------------------//.
동적 프로그래밍 : 하나의 문제를 여러개의 작은 문제로 나누어 풀고, 결합하여 해결하는 방식이다.
                 작은 문제가 다른 작은 문제를 해결하는데 사용이 될수 있기 때문에 여러번 계산하는것이 아닌,
                 한번 계산을 하고 난 후, 재황용 하여 메모이제이션 기법으로 속도를 향상 한다.

메모이제이션 : 동일한 계산을 반복해야 할 때, 이전 계산값을 저장하여 동일한 반복 수행을 제거하여
              프로그램 실행 속도를 빠르게 하는 기술이다.
              
동적 프로그래밍의 조건
1. 중복되는 부분 문제가 있어야 한다.
2. 최적 부분 구조
//---------------------------------------------------------------//.

[동일성 과 동등성]
//---------------------------------------------------------------//.
동일성 : 인스턴스가 실제로 같은 인스턴스라는 것을 의미한다. (==)
동등서 : 서로 다르 인스턴스 지만 가지고 있느 값이 같음을 의미한다. (equals)
//---------------------------------------------------------------//.

[클린코드]
//---------------------------------------------------------------//.
코드가 군더더기 없이 깔끔하고, 기능을 수행하는데 있어 적은 라인을 처리가 되어있는 코드.
또한 직접적이고, 에러처리가 잘되어 있으며 하나의 역할을 수행한다.
//---------------------------------------------------------------//.

★★★★★자료구조★★★★★  

[자료구조]
//---------------------------------------------------------------//.
*여기서도 실수가 있었다. 많이 긴장을 하고, 빨리 대답을 해야할 거 같은 부담에 힙과 큐를 헷갈려 말했다..
*데크는 생각조차 나지 않았다.

스택 Stack
LIFO구조이다.
PUSH로 넣고, POP으로 꺼낸다.
한쪽으로만 데이터를 넣고 꺼낸다.

큐 Queue
FIFO구조이다.
한방향으로만 데이터를 넣고, 꺼낼수가 있다.(스택과는 다르다.)
Rear에서 Enqueue로 넣고, Front에서 Dequeue로 꺼낸다.

힙 Heap
특정한 규칙을 가지는 트리이다.
트리구조와 배열로 모두 구현 가능하다.
우선사항이 고려된 이진트리 이다.
Root에 가장 큰것을 놓고, 자식 노드에는 작은 것을 놓는다.

덱 Deque
양쪽 방향으로 넣고 꺼낼 수 있다.
스택과 큐의 특성을 모두 가지고 있어 덱을 스택과 큐 모두로 활용할 수 있다.
양방향 연결 리스트로 구현한다.
//---------------------------------------------------------------//.

[트리 구조]
//---------------------------------------------------------------//.
트리란 그래프의 일종으로 여러개의 노드가 하나의 노드를 가리킬 수 없는 구조이다.
서로 다른 노드를 잇는 길이 하나뿐인 그래프를 트리라고 한다.
//---------------------------------------------------------------//.

[ArrayList 와 LinkedList]
//---------------------------------------------------------------//.
ArrayList : 리스트의 크기가 제한이 되어 있고, 크기 재조정에 많은 연산이 필요하다.
            데이터의 추가 및 삭제시 배열을 생성하여 복제하기 때문에 시간이 오래 걸린다.
            무작위 접근이 가능하다.
            
LinkedList : 리스트의 크기와 상관없이 데이터를 추가 할수 있다.
             추가 및 삭제시 해당 노드를 생성하여 연결하고 삭제하기 때문에 연산이 빠르다.
             무작위로 접근이 불가능하고, 순차적으로 접근을 해야한다.
//---------------------------------------------------------------//.


[WAS와 WS]    
//---------------------------------------------------------------//.    
WAS는 Web Application service의 약자로 비즈니스 로직을 넣을수 있다. (tomcat등)    
WS는 Web service의 약자로 비즈니스 로직을 넣을수 없다. (Apache등)    

그럼 비즈니스 로직이란?     
로그인을 예로 들었을 경우, 크게 두가지 상황이 발생한다.    
1. 로그인을 하고자 하는 사람에게 [로그인 성공, 로그인 실패, 비밀번호 잘못 되었습니다.]등 안내 문구    
2. DB에서 로그인의 정보를 검색 및 조회 등 활동을 한다.
    
이때 비즈니스 로직은 2번에 해당한다.    
//---------------------------------------------------------------//.    

[컴포넌트와 모듈]    
//---------------------------------------------------------------//.    
컴포넌트 : 실제 동작하는 개체 혹은 독립적인 단위    
모듈 : 구현이 된 단위, 알고리즘 또는 자료구조 등 제공하는 인터페이스    

가장 쉬운 예)
1개의 서버와 20개의 클라이언트가 있을때
모듈은 21개가 되고, 컨포넌트는 2개가 된다.
//---------------------------------------------------------------//.    

★★★★★운영체제★★★★★    

[프로세스와 스레드]
//---------------------------------------------------------------//.    
프로세스는 실행중인 프로그램.
스레드는 프로세스 내의 독립적으로 실행되는것을 의미한다.
또한
프로세스는 운영체제에게 자원을 할당 받지만, 스레드는 프로세스에 의해 자원을 할당 받는다.

스레드는 적은 메모리를 사용하고, 전역 메모리를 공유한다는 장점이 있지만 교착상태가 발생할수 있다는 단점이 있다.
여기서 멀티 스레드 프로그래밍은 무엇일까?
하나의 프로세스에서 여러개의 스레드를 만들어 자원을 생성및 관리하고 중복을 최소화 한다.
//---------------------------------------------------------------//.    

[동기 및 비동기]
//---------------------------------------------------------------//.    
동기 : 요청을 보낸후 응답을 받아야만 다음 동작이 이루어진다. (블럭)
비동기 : 요청을 보낸후 응답과 상관없이 다음 동작을 한다.     (논블럭)

프로세스 동기화란? 프로세스가 공유 자원을 사용하는 상황에서 공유 자원을 신뢰할수 없기 때문에(경쟁 조건) 이것을 방지하기 위해
                  실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것이다.

//---------------------------------------------------------------//.    

[교착상태]
//---------------------------------------------------------------//.    
교착상태 : 하나이상의 프로세스가 서로 상대방의 작업이 끝나기를 기다리는 상태.

발생조건: 상호배제 : 한 리소스는 하나의 프로세스만 이용할수 있다.
          비선점 : 리소스를 자발적으로 반환하기를 기다린다.(뺏지 않음)
         원형대기 : 프로세스들이 서로를 기다린다.
         점유와대기 : 하나의 프로세스가 리소스를 점유하고 있으면서 다른 리소스를 기다린다.
         
해결방법: 예방 : 발생조건이 만족되지 않게 한다.
         회피 : 발생조건을 없애는 것이 아닌, 알고리즘을 이용하여 해결한다. ex)은행원 알고리즘
         탐지 : 원인을 규명하여 해결한다. ex)자원할당 그래프
         회복 : 교착상태가 발생하면 그 후에 해결하는 방법
//---------------------------------------------------------------//.    


[기아상태]
//---------------------------------------------------------------//.    
기아상태 : 프로세스가 필요한 자원을 할당 받지 못하고 계속 기다리고 있는 상태이다.
//---------------------------------------------------------------//.    

[경쟁상태]
//---------------------------------------------------------------//.    
경쟁상태 : 여러 프로세스가 공유자원에 접근할때 공유 데이터에 대한 실행 순서에 따라 결과가 달라지는 상황이다.
//---------------------------------------------------------------//.    

[임계영역]
//---------------------------------------------------------------//.    
임계영역 : 둘 이상의 프로세스가 동시에 접근하면 안되는 공유 자원(임계영역)에 접근하는 영역(코드 영역)
          즉, 프로그램에서 공유 데이터(임계 자원)를 이용하는 부분이다.
 
문제점: 동시에 접근하게 되면 예상치 못한 결과가 나오게 된다. -> 경쟁상태
//---------------------------------------------------------------//.    


[메모리 누수]
//---------------------------------------------------------------//.    
프로그램이 필요없는 메모리를 점유하고 있는 현상이다.
자바의 경우는 GC가 있어 사용하지 않는 객체는 회수하여 메모리 공간을 확보한다.

누수를 막기위해 Local변수로 만들어 자동으로 GC가 되게 만들면 된다.
즉 참조값을 갖는 변수가 최소 유효범위 안에 있도록 하면 된다.
//---------------------------------------------------------------//.    


[도커]
//---------------------------------------------------------------//.    
도커는 컨테이너 기반의 가상화 기술이다.
초기에는 OS를 가상화 하였고, HOST OS위에 GUEST OS를 설치했기 때문에 무겁고 느렸다는 한계가 있었다.
그렇기 때문에 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 도커라는 기술이 등장하였다.

장점: 실행 환경 구축이 쉽고 빠르다.
      공유 환경을 제공한다.
      하드웨어 자원이 절감된다.
단점: 개발 초기의 오버헤드 (도커를 처음 쓰는 개발자일때, 초반 환경 설정시 시행착오가 많음)
      리눅스 친화적이다. (도커를 제대로 쓰기 위해서는 linux기반os에서 사용해야 한다.)
//---------------------------------------------------------------//.    

[프로그램 과 프로세스]
//---------------------------------------------------------------//.    
프로세스란 현재 실행되고 있는 프로그램을 프로세스 라고한다.
그럼 프로그램이 프로세스인가?

프로그램 : 실행 파일로 파일 시스템에 존재하는 실행 파일이다.
프로세스 : 프로그램을 실행시켜주는 주체(인스턴스)
라고 세부적으로 말할수 있다.

대게 프로세스란 위에서 말한대로 -> 실행되고 있는 프로그램이라고 말해도 된다.

하나 예를 들면,
인터넷 창(크롬)을 3개 켰을때, 하나의 크롬(프로그램)을 실행시켜 3개(프로세스)를 만든것이다.
//---------------------------------------------------------------//.    


[JVM]
//---------------------------------------------------------------//.    
JVM은 자바를 실행하기 위한 환경이다.
JVM의 구조를 설명.
1. 프로그램을 실행하기 위해 OS에게 메모리를 할당받는다.
2. 자바 컴파일을 통해 .java 파일을 .class로 변환을 한다.
3. 그후 class loader를 통해 jvm에 로딩을 시킨다.
4. 로딩된 바이트 코드를 execution engine을 통해 기계어로 번역이 된다.
5. 해석이 된 바이트 코드는 runtime data areas에 배치되서 실직적인 수행이 된다.

//---------------------------------------------------------------//.    

[직렬화 와 역직렬화]
//---------------------------------------------------------------//.    
자바에서 입출력은 stream이라는 통로로 데이터가 이동한다. 이때 객체는 바이트형이 아니기 때문에 stream을
저장하거나 네트워크로 전송할 수가 없다. 그래서 객체를 stream을 통해 입출력을 하기 위해 바이트 배열로 변환 하는 과정이 필요한데
이것을 직렬화라고 한다.

반대로 stream을 통해 받은 직렬화된 객체를 다시 원래의 형태로 바꾸는 것을 역직렬화 라고 한다.
//---------------------------------------------------------------//.    



회사에 대한 질문
//---------------------------------------------------------------//.   
1. 현업에서는 어떤 툴이나 기술을 이용하는지 알고싶다.
2. TDD(Test Driven Development)나 BDD(Behavior-Driven Development) 또는 DDD(Domian-Driven Development)를 사용하는가?
3. 요즘 해당 팀에서 관심있게 생각하는 기술이나 스킬은 무엇인가?
//---------------------------------------------------------------//.    

