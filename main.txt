깃 연동
Interview-Question.
//----------------------------------------------------------------//

★★★★★데이터베이스★★★★★

[SQL]
//---------------------------------------------------------------//.    
데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)을 포함한 데이터베이스용 질의 언어의 일종으로
데이터베이스를 사용할때 데이터베이스에 접근할 수 있도록 하는 데이터베이스 하부언어 이다.
//---------------------------------------------------------------//.    

[테이블]
//---------------------------------------------------------------//.    
테이블 : 행과 열로 이루어진 데이터의 집합이다.
         RDB에서는 테이블을 릴레이션이라고도 한다.
         모든 릴레이션은 테이블이지만, 모든 테이블은 릴레이션이 아니다.
         -> 조건이 충족 되어야 한다.
            1. 모든 값을 유일한 값을 가진다.
            2. 하나의 릴레이션에는 중복되는 행이 존재해서는 안된다.
//---------------------------------------------------------------//.    

[ROW]
//---------------------------------------------------------------//.    
행 : 테이블을 구성하는 데이터의 가로로 묶은 데이터셋을 의미한다.
     행은 한 객체에 대한 정보를 가지고 있다.
     튜플 또는 레코드 라고한다.
//---------------------------------------------------------------//.    

[Colum]
//---------------------------------------------------------------//.    
열 : 테이블을 구성하는 데이터의 세로를 묶은 데이터셋을 의미한다.
     열을 구성하는 값은 같은 도메인으로 되어 있다.
     속성이라고도 한다.
//---------------------------------------------------------------//.    

[인덱스]
//---------------------------------------------------------------//.    
인덱스 : 데이터베이스 테이블의 검색속도를 향상시키기 위한 자료구조이다.

인덱스의 단점 : 인덱스를 구축하는 비용 발생.
               추가,삭세,수정 연산시 인덱스를 형성하기 위한 추가 연산이 필요하다.
//---------------------------------------------------------------//.    


[클러스터 인덱스와 넌클러스트 인덱스].
//----------------------------------------------------------------//.
클러스터 : 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이 자주 사용되는 테이블의 데이터를 디스크의 같은 위치에 저장 시키느 방법. 

-클러스터 인덱스.

하나의 테이블에 한개만 생성이 가능하다.
조회는 빠르지만, 수정 삽입 삭제는 느리다.
물리적으로 행을 재배열한다.
인덱스 페이지 용량이 넌클러스터 보다 작다.


-넌클러스터 인덱스.

하나의 테이블의 여러개 생성이 가능하다.
조회는 느리지만, 수정 삽입 삭제가 빠르다.
물리적으로 재배열을 하지 않는다.
인덱스 페이지 용량이 클러스터 인덱스 보다 크다.
//----------------------------------------------------------------//.

[View]
//---------------------------------------------------------------//.
View : 물리적인 테이블을 근거한 논리적인 가성 테이블

특징: 보안에 유리하고 , 복잡하고 긴 쿼리문을 뷰로 정의하면 단순화 할수 있다.
//---------------------------------------------------------------//.

[rollback 과 commit]
//---------------------------------------------------------------//.    
rollback과 commit은 insert,update,delete문을 사용했을때 사용하는 쿼리문이다.
rollback은 데이터를 수행전으로 되돌리고 싶을때 사용을 한다.
commit은 쿼리문을 수행후 해당 결과에 대해 확정 하는 것이다.
//---------------------------------------------------------------//.    

[트랜잭션]
//---------------------------------------------------------------//.    
트랜잭션이란 : 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업단위
트랜잭션은 성공하려면 성공해야하고, 실패하려면 전부 실패 해야한다.
//---------------------------------------------------------------//.    

[정규화]
//---------------------------------------------------------------//.    
정규화 : 데이터의 중복을 방지하고, 무결성을 충족하기 위해 DB를 설계하는 것을 의미한다.
정규화를 하지 않으면 이상현상이 발생하는데 이를 없애고자 한다.
이상현상에는 삽입이상, 삭제이상, 삽입이상이 있다.
//---------------------------------------------------------------//.    

[스키마]
//---------------------------------------------------------------//.    
스키마 : 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
        (자료의 구조, 자료의 표현 방법, 자료 간의 관계)
 
외부 스키마 : 사용자 입장에서 정의한 논리적 구조
개념 스키마 : 조직체 전체입장에서 DB를 정의한 스키마
내부 스키마 : 어떻게 저장될지에 대한 명세
//---------------------------------------------------------------//.    

[RDBMS 와 NoSQL]
//---------------------------------------------------------------//.    
RDBMS : 정형데이터를 저장한다.
        연산이 가능하다.
        각각의 속성과 값을 가진 테이블들은 서로 관계를 맺으며 존재한다.
        데이터의 분류, 탐색, 정렬의 속도가 비교적 빠르다.
        
NoSQL : 비정형데이터를 저장한다.
        연산이 불가능하다.
        데이터와 테이블간의 관계를 정의하지 않는다.
        스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어 있지 않다.
//---------------------------------------------------------------//.    


[키]
//---------------------------------------------------------------//.
기본키 : 유일하게 식별가능한 키로, null이 될수 없고 최대한 적은 속성을 가져야한다.
외래키 : 다른 릴레이션을 참조하는 속성을 말한다. 참조되고 참조하는 릴레이션의 도메인이 같아야한다.
//---------------------------------------------------------------//.

[ACID]
//---------------------------------------------------------------//.
원자성 : 트랜잭션의 모든 연산은 완벽하게 실행되어야 하며, 실패하면 트랜잭션은 실패해야 한다.
일관성 : 트랜잭션은 유효한 상태로만 변경할 수 있다.
고립성 : 하나 이상의 트랜잭션이 동시에 실행될 경우 다른 트랜잭션에 영향을 받지 않고 독립적으로 실행해야 한다.
내구성 : 트랜잭션이 커밋이 되었을때, 시스템 오류가 생겨도 커밋된 상태를 유지해야 한다.
//---------------------------------------------------------------//.

[트리거]
//---------------------------------------------------------------//.
트리거 : 자동으로 실행도록 정의된 프로시저이다. INSERT DELETE UPDATE에 대한 응답으로 자동 호출한다.

업무 자동화를 하고 무결성을 강화하기 위해 사용한다.
//---------------------------------------------------------------//.

[Dead Lock]
//---------------------------------------------------------------//.
데드락 : 두 개이상의 트랜잭션이 특정 자원의 잠금을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도
         상황이 바뀌지 않는 상태

빈도 낮추는 방법
1. 트랜잭션을 자주 커밋
2. 정해진 순서로 테이블 접근
//---------------------------------------------------------------//.

[참조 무결성]
//---------------------------------------------------------------//.
기본키와 참조키간의 관계가 항상 유지됨을 보장한다.
참조되는 테이블의 행을 이를 참조하는 참조키가 존재하는 한 삭제 할수 없고, 기본키도 변경할 수 없다.
//---------------------------------------------------------------//.

[JOIN]
//---------------------------------------------------------------//.    
JOIN은 서로 다른 테이블에서 하나의 결과를 도출 할때 사용하는 방법이다.

INNER JOIN : 키값이 있는 테이블의 컬럼 값을 비교후 조건에 맞는 값을 가져온다.
OUTER JOIN : 조인하는 여러 테이블에서 한쪽에 데이터가 있고, 한쪽에 없는 경우 데이터가 있는 쪽 테이블의 내용을 전부 출력하는 방법이다.
CROSS JOIN : 조인되는 두 테이블을 곱집합을 반환한다.
//---------------------------------------------------------------//.    

★★★★★네트워크★★★★★

[OSI 7Layer 와 TCP/IP 4Layer]
//---------------------------------------------------------------//.    
OSI 7Layer             TCP/IP 4Layer

응용 계층
표현 계층                 응용 계층
세션 계층
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
전송 계층                 전송 계층
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
네트워크 계층             인터넷 계층
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 링크 계층         네트워크 엑세스
물리 계층                    계층


OSI 7계층이 존재하는 이유?
통신이 일어나는 과정을 단계별로 파악할수 있기 때문이다.
한눈에 보기에 쉽고, 사람이 이해하기 쉬우며, 특정 한곳에서 문제가 발생할시 다른 단계의 소프트웨어나 장비를 건들이지 않고 해당 단계만
고칠수 있다는 점도 있다.
//---------------------------------------------------------------//.    

[로드 밸런싱]
//---------------------------------------------------------------//.    
로드 밸런싱 : 여러 서버에 균등하게 트래픽을 분산 시켜주는 것이다.

보통 서버에 많은 트래픽이 모여 과부하 발생되기 때문에 성능을 올리거나, 서버를 여러개 둔다.

//---------------------------------------------------------------//.  

[DNS]
//---------------------------------------------------------------//. 
Domain Name Server로 우리가 알고있는 주소를 컴퓨터가 이해하는 ip주소로 변환하여 사용자의 컴퓨터가 서버로 접근할수 있게 해주는 서버이다.
DNS의 구조는 루트 도메인 -> 1단계 도메인(최상위 도메인) -> 2단계 도메인 -> 3단계 도메인 -> 4단계 도메인(서브 도메인)으로 이뤄져 있다. 
최상위 도메인은 은 www.google.co.kr에서 kr을 의미하고 co는 2단계, 이런식으로 거꾸로 간다.
//---------------------------------------------------------------//. 

[Cast의 종류]
//---------------------------------------------------------------//.
- Unicast : 1:1 통신, 원하는 대상 하나를 정해서 통신
- Multicast : 1:N통신, 원하는 대상 여러 명을 정해서 통신
- Broadcast : 1:all 통신, 내 의지와 상관없이 무조건 받아들여야 하는 통신
//---------------------------------------------------------------//.

★★★★★WEB★★★★★
[Http와 Https].
//----------------------------------------------------------------//.
어떠한 요청을 웹 브라우저가(클라이언트) 웹 서버에 무언인가 요청을 할 때 사용하는 프로토콜이다.

http.

서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜.
80번 포트를 사용하고, 클라이언트의 요청도 80번 포트로 보낸다.
Https.

Http에 데이터 암호화를 추가한 프로토콜이다.
SSL인증서를 사용한다.
433번 포트를 사용하고, 공개키 암호화를 지원한다.
SSL인증서는 사용자가 사이트에 제공하는 정보를 암호화 하고,
TLS(전송계층 보안)프로토콜을 통해서도 보안을 유지한다. TLS는 데이터 무결성을 보장하기 때문에 데이터가 도중에 수정 및 손상을 방지하고, 사용자가 사신이 의도하는 웹사이트와 통신하고 있다는 것을 입증하는 인증 기능도 제공한다.

=>Http는 보안에 취약한 반면 Https는 안전하게 데이터를 주고 받을 수 있다. 하지만 Https는 암호화와 복호화 과정이 필요하기 때문에 Https보다 속도가 느리다. (요즘은 거의 차이가 나지 않는다.) 또한 Https는 인증서를 발급하고 유지하기 위해 추가 비용이 발생한다.
//----------------------------------------------------------------//.

[Session 과 Cookie].
//---------------------------------------------------------------//.
사용이유 : HTTP프로토콜의 특징이자 약점을 보호하기 위해 사용한다.

HTTP 프로토콜의 특징.
비연결지향 : 요청하고, 응답을 한 후에 연결을 끊는 특정이 있다.
상태없음 : Connection을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는다.

=> 비연결지향이기 때문에 서버 리소스 낭비가 줄어든다는 장점이 있지만, 통신을 할때마다 새로운 커넥션을 만들어야 하기 때문에 클라이언트 쪽에서는 상태를 유지를 위해 통신 할때마다 어떤 절차를 거쳐야한다.
즉, 세션 및 쿠키가 없다면 다른 페이지로 넘어갈때마다 인증을 다시 받아야 한다.

쿠키(Cookie).
클라이언트 로컬에 저장되는 key와 value이 들어있는 작은 데이터 파일.
이름,값,만료날짜/시간,경로 정보 등이 들어있다.

-세션 쿠키 : 브라우저 메모리에 저장되므로 브라우저가 종료되면 쿠키는 사라진다.(만료 날짜/시간).
-지속 쿠키 : 파일로 저장되므로 브라우저가 종료되어도 쿠키는 남아있게 된다.(XXX 만료 날짜/시간 XXX).

세션(Sesstion).
서버에 클라이언트의 상태 정보를 저장하는 기술로 논리적인 연결을 세션이라고 한다.
웹 서버에 클라이언트의 정보를 저장하고, 클라이언트에게 구분을 위한 ID를 부여하는데 이것이 세션이다.

차이점.
저장 위치 : 쿠키는 클라이언트의 메모리 또는 파일, 세션은 서버 메모리에 저장된다.
보안 : 쿠키는 로컬에 저장되기 때문에 변조, 탈취 위험이 있지만, 세션은 서버에 있어 비교적 안전하다.

//---------------------------------------------------------------//.

[MVC패턴].
//---------------------------------------------------------------//.
사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.

Model - 백그라운드에서 동작하는 로직을 처리한다. (데이터를 가진 객체, 파라미터로 주로 쓰인다.) , DB의 테이블과 대응하는 경우가 많다.
View - 사용자가 보게 될 결과 화면을 출력한다. (HTML,CSS,Javascsript를 모아둔 컨테이너).
Controller - 사용자의 입력처리와 흐름 제어를 담당한다. (사용자가 접근한 URL에 따라서 사용자의 요청사항을 파악 후, 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영하여 사용자에게 알려준다.)

MVC 패턴 특징 - 전체적인 구조에 관련된 패턴으로 도메인(비즈니스)과 UI로직을 분리하여 유지보수를 독립적으로 수행할 수 있게 한다.
//---------------------------------------------------------------//.    

[TCP와UDP]
//---------------------------------------------------------------//.    
TCP는 연결형 서비스를 지원하는 전송계층의 프로토콜이다. 호스트간 신뢰성 있는 통신을 하고, 흐름제어 및 혼잡제어를 제공한다.
UDP는 비연결 서비스를 지원하는 전송계층의 프로토콜이다. 신뢰성이 낮고, 속도는 빠르다. 또한 handshaking과 같은 설정은 필요없다.
//---------------------------------------------------------------//.        

[handshaking]
//---------------------------------------------------------------//.    
handshaking은 크게 3-way와 4-way가 있다.

3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면, 
4-Way handshake는 세션을 종료하기 위해 수행되는 절차입니다.

//---------------------------------------------------------------//.    

[RESTful API]
//---------------------------------------------------------------//.    
HTTP통신에서 CRUD요청을 리소스와 메소드로 표현하여 특정한 형태로 전달하는 방식이다.
리소스 : 자원 , URI
메소드 : 요청방식으로 GET 또는 POST등
Representation of Resource: 자원의 형태로 json 또는 xml등
//---------------------------------------------------------------//.    

[GET 과 POST]
//---------------------------------------------------------------//.   
GET과 POST는 클라이언트가 서버에 요청을 보내는 방법으로 HTTP Method의 방식이다.
GET : -GET요청은 파라미터에 정보가 담겨있기 때문에 중요한 정보는 보내면 안된다.
       ex) www.github.com/wami?password=12345&Id=wami  <- 실존하지 않는 주소지만 ?부터 정보가 담겨있다.
      -요청의 길이가 제한이 되어있다. (브라우저마다 제한이 다르다.)\
      -데이터를 요청할 때만 사용한다.
      -캐싱이 가능하다.
 
 POST : -POST요청은 BODY에 전송하고자 하는 데이터를 담아서 서버로 보낸다.
        -길이 제한이 없다.
        -캐시되지 않는다.
        -데이터가 외부에 드러나 있지 않아 보안에 좋다.
        
이외에도 다른 메소드도 존재한다.
그의 대한 설명은 아래 참고
https://alka-loid.tistory.com/63
//---------------------------------------------------------------//.    


[HTTP 와 SOCKET]
//---------------------------------------------------------------//.    
HTTP : 단방향적 통신으로, 클라이언트의 요청이 있을때 서버가 응답을 한다.
       그후 바로 연결을 종료한다. 즉, 실시간 연결이 아닌 필요할때 SERVER로 접근하는 컨텐츠 위주의 데이터를 사용할때 용이하다.

SOCKET : 양방향 통신으로 클라이언트와 서버가 특정 PORT를 통해 실시간으로 통신을 한다.
         양방향이기 때문에 server또한 client에게 요청을 보낼수 있다.
//---------------------------------------------------------------//.    


[웹 통신의 흐름]
//---------------------------------------------------------------//.    
사용자가 브라우저에 도메인 이름을 입력한다. 예로, www.naver.com
DNS서버에서 사용자가 입력한 domain name을 검색하여 맵핑하는 ip주소를 찾는다.
그후 ip주소는 HTTP프로토콜을 이용해 HTTP요청 메세지를 생성하여 TCP프로토콜을 사용해
인터넷을 거쳐 해당 ip주소의 컴퓨터(서버)로 전송이된다.
서버는 요청을 승인한후 해당 메세지를 받아 응답 메세지를 전송한다.
해당 메세지는 http프로토콜을 사용하여 웹페이지 데이터로 변환되어 웹 브라우저에 출력되어 사용자가 볼수 있게 된다.

그럼 OSI 7Layer로 설명을 해보면
브라우저가 URL에 적힌 값을 파싱하여 HTTP요청 메세지를 만들어 OS에 전송 요청을 한다. 이때 DOMAIN은 www.naver.com과 같은 표현이기 때문에
보낼수가 없어 DNS LOOKUP을 수행하여 IP를 찾는다. 대게 DNS lookup은 루트 도메인 서버 -> 서브 도메인 서버 순으로 찾는다. 
www.naver.com과 같은 경우에는 .com이 루트 도메인 서버가 된다.
크롬 브라우저는 브라우저 -> hosts파일 -> dns cache순으로 도메인에 매칭되는 ip를 찾는다.
ip를 찾고 난후 해당 요청은 os에 내장되어 있는 네트워크 제어용 소프트웨어에 의하여 패킷에 담기고 패킷에 제어정보를 담아 LAN어댑터에 전송한다.
LAN어댑터는 이를 전기신호로 바꾸어 송출한다.
응용 계층->표현 계층->세션 계층->전송 계층->네트워크 계층->데이터링크 계층->물리계층 순으로 정리가 된것이다.

송출된 패킷은 스위칭 허브등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달이 되고 인터넷으로 이동을 한다.
그후 액세스 회선을 통해 통신사용 라우터로 운반되고 인터넷의 핵심부로 이동이 된다.
그리고 고속 라우터를 이동하면서 최종 목적지 까지 패킷이 이동된다.

목적지 까지 도착한 패킷은 LAN에 도착하여 방화벽이 패킷을 유효성 검사를 하고 캐시서버로 보내서 웹 서버에 갈수 있는지 확인한다.
웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출 하여 메세지를 복원하고 웹 서버 어플리케이션에 넘기게 된다. 
해당 메세지를 확인하여 응답 메세지를 작성하여 다시 클라이언트로 위와 같은 과정을 거친다.
물리 계층->데이터 링크 계층->네트워크 계층->전송 계층->세션 계층->표현 계층->응용 계층 순으로 정리가 된것 이다.
//---------------------------------------------------------------//.    

[캐시]
//---------------------------------------------------------------//.    
캐시 : 자주 사용하는 값이나 데이터를 미리 복사해 놓는 임시 저장소.
      저장 공간이 작고, 빠르지만 비용이 비싸다.
      
사용 용도 : 반복적으로 동일한 결과를 반환할때 사용한다. (이미지 및 썸네일)
          데이터의 접근 시간이 오래 걸릴 경우(서버의 균일한 API데이터)
//---------------------------------------------------------------//.    

[대칭키와 비대칭키]
//---------------------------------------------------------------//.    
대칭키 : 하나의 비밀키를 이용하여 암호화하는 방식이다.
비대칭키 : 하나의 공개키와 하나의 비공개키를 이용하여 암호와 하는 방식이다.
          암호화를 진행할때는 공개키, 복구할때는 비밀키를 이용한다.
//---------------------------------------------------------------//.    

[Express]
//---------------------------------------------------------------//.    
node js웹 어플리케이션 프레임워크로 Rest API를 만들어 내기 위한 여러 도구가 있다.
//---------------------------------------------------------------//.    

[Node JS]
//---------------------------------------------------------------//.    
자바스크립트를 백엔드에서도 사용할수 있도록 해주는 실행 환경이다.

//---------------------------------------------------------------//.    


[생명주기].
//---------------------------------------------------------------//.
*순간. 멍해져 간단한 질문이었지만, 대답을 하지 못했다.
-SDLC는 개발과 유지보수 등에 필요한 작업들을 체계적으로 정리한 방법론이다.

※생명주기 순서※.
계획 -> 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수.
//---------------------------------------------------------------//.

[Opencv를 이용하면서 CUDA를 사용한 방법].
//---------------------------------------------------------------//.
*이부분도 대답을 제대로 하지 못했다. cuDNN이 갑자기 생각이 나지 않았다..
*모든것이 끝나고 생각이 났다.. 아래 대답은 개인적인 대답이기 때문에 자세한건 더 공부를 해야한다.
*개인적인 대답이지만, 해당 방법이 정확하다.

사용방법은 되게 간단하다. (사용은 편하지만 사용을 하기 이전 환경설정 하는것이 되게 힘들다.).
일단 NVIDIA그래픽에 맞는 CUDA를 설치하였다.
Tensorflow를 사용할 예정이 었기 때문에 Tensorflow에 호환이 되는 Cuda,cuDNN을 설치하고,
이어서 cmake를 이용하여 opencv빌드 옵션을 설정하여 pycham에서 opencv빌드를 진행하였다.

＃cmake : 빌드 도구로 플렛폼에 독집적인 환경을 제공하고, 컴파일 과정을 제어할수 있도록 하는 크로스플렛폼이다.
＃cuDNN : 딥러닝연산을고려하는 하드웨어가 나오면 그것을 뒷바침해주는 딥러닝 기반의 소프프웨어있어야 하는데, cuDNN은 그러한 라이브러리이다.
//---------------------------------------------------------------//.

[CUDA(GPU)에서 병렬 처리하는 방법].
//---------------------------------------------------------------//.
*프로젝트 완성에 급급하여 제대로 공부를 못한것이 실수였다.
*이제는 한번 공부하는 내용은 100%는 아니더라도 이해와 숙지가 필요할것 같다.

CUDA는 C/C++언어로 병렬계산에 필요한 기능을 제공해주는, NVIDIA에서 제공하는 소프트웨어이다.

CPU와 GPU의 기본적인 차이를 우선 알아보아야 한다.

GPU는 CPU와는 달리 코어가 아주 많다.
CPU는 복잡한 계산을 빠르게 처리하지만 모두 직렬로 처리한다.
GPU는 간단한 계산을 빠르게 처리할 수 있고, 많은 연산을 병렬로 동시에 처리한다.
위를 풀면 CPU는 시스템 자원을 제어하고, 복잡한 명령을 처리하기 때문에 다양한 구성요소가 존재하지만, GPU는 그래픽처리를 위해 만들어진 장치이기 때문에.
단순한 연산을 고속으로 처리가 가능했다. 그렇기 때문에 GPU는 단독으로 시스템 자원을 활용 할수가 없어, CPU의 제어가 필요하다.

그럼 이제 병렬처리하는 방법을 알아보자.

병렬처리할 데이터를 MAIN MEMORY에서 GPU MEMORY로 이동을 시킨다.
CPU는 GPU에게 GPU MEMORY에 있는 데이터를 가지고 연산을 하라고 제어(명령)한다.
GPU는 CPU가 명령령한 연산처리를 병렬로 수행한다.
GPU가 작업을 마치며녀 GPU MEMORY에 결과를 저장하고, 다시 MAIN MEMORY에 결과를 업로드한다.
마지막으로 CPU가 MAIN MEMORY에 접근해 해당 결과물을 이용하여 작업을 마무리한다.
//---------------------------------------------------------------//.


[딥러닝 GD 와 SGD]
//---------------------------------------------------------------//.
*이부분은 예전에 들어는 봤으나, 제대로 학습이 안된 부분이어서 대답을 하지 못했다.

GD와SGD를 알아보기 전에 이것이 무엇인지 알아야 한다.
기존 뉴럴 네트워크는 weight parameter를 최적화(optimize)하기 위해 GD방법을 사용하였다.
즉, 위의 GD와 SGD는 옵티마이저 종류중 하나이다.
GD(gradient Descent)

모든 자료를 다 검토하여 내 위치의 산기울기를 계산하여 방향을 찾는다.(full batch)
한번에 모든 Data set을 Training을 한다.
SGD(Stochastic Gradient Descent)

전부 다 봐야하는 한걸음(GD)은 너무 오래 걸려 조금만 보고 빨리 판단 한다.(mini-batch)
같은 시간에 더 많이 간다.
한번 볼때 일부 Data Set을 보고, 일부만 Training한다.
//---------------------------------------------------------------//.


[CUDA스레드와 일반 스레드 차이]
//---------------------------------------------------------------//.
기본적으로 GPU와 CPU의 코어는 다른 구조를 가지고 있다. GPU는 코어갯수 * 코어 클락으로 이루어져 있다.

CPU는 멀티 코어를 구성하는 전체 요소로, CPU에서 하나의 칩당 멀티 코어로 4~12개 정도의 코어를 가지고 있다.

GPU는 구성요소를 멀티 프로세서 라고 한다. 그 구성요소중 계산 유닛이 존재하는데, 그것을 GPU의 코어 라고한다.
GPU는 하나의 칩당 최대 15개의 멀티 프로세서를 가지고 있고, 이 멀티 프로세서 안에는 192개의 코어(계산 유닛)을 가지고 있다.
그렇기 때문에 15 * 192인 2880개의 코어를 가지고 있다. //---------------------------------------------------------------//.

[메모리 구조]
//---------------------------------------------------------------//.
메모리 구조에 크게 4가지 영역이 존재한다.

코드(code) 영역
데이터(data) 영역
스택(stack) 영역
힙(heep) 영역

첫번째 코드(code) 영역
실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부른다.
CPU는 코드 영역에 저장된 명령어를 하나씩 가져가 처리한다.

두번째 데이터(data) 영역
프로그램의 전역 변수와 정적(Static)변수가 저장되는 영역이다.
데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.

세번째 스택(stack) 영역
함수 호출과 관계되는 지역변수와 매개변수가 저장되는 영역이다.
LIFO방식에 따라 동작하며 메모리의 높은 주소에서 낮은 주소의 방향으로 할당 된다.

네번째 힙(heap)영역
사용자가 직접 관리하고 해야만 하는 영역이다. 사용자에 의해 동적으로 할당되고 해체된다. 그리고 낮은 주소에서 높은 주소의 방향으로 할당 된다.

한줄로 표현
코드영역: 실행할 프로그램의 코드
데이터 영역 : 전역변수, 정적 변수 
스택 영역 : 지역변수, 매개변수
힙 영역 : 사용자의 동적 할당
//---------------------------------------------------------------//.


★★★★★언어★★★★★

[아키텍처]
//---------------------------------------------------------------//.
아키텍처란 컴퓨터 시스템의 하드웨어 구조를 말한다.
cpu나 기억장치, 입출력 장치등 컴퓨터를 구성하는 요소들에 전반적인 기계적 구조와 이를 설계하는 방법이다.
//---------------------------------------------------------------//.

[C와 JAVA]
//---------------------------------------------------------------//.    
C와 JAVA의 가장 큰 차이는 절차지향인과 객체지향이라는 것이다.
객체지향과 절차지향에 대한 설명은 밑에서 따로 정리할 것이다.

C는 작동방식이 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향의 언어보다 빠르게 처리된다.
또한, 유지보수가 어렵고, 사용자가 직접 메모리를 조절하여 사용해야 한다.

JAVA는 JVM위에서 작동하기 때문에 운영체제에 독립적이다.
또한, GC으로 사용하지 않는 메모리를 자동으로 정리한다.
캡슐화, 다형성, 상속등 특징이 있다.
//---------------------------------------------------------------//.    

[절차지향 과 객체지향]
//---------------------------------------------------------------//.    
절차지향은 순차적인 처리가 중요시 되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.
컴퓨터와 작업 처리 방식이 유사 하기 때문에 빠르지만, 유지보수가 어렵고, 프로그램의 실행 순서가 바뀌면 동일한 결과를 보장받기 힘들다.

객체지향은 실제 세계를 모델링 하여 소프트웨어를 개발하는 방법이다. 코드의 재사용성이 높고 절차지향보다 간편하다.
하지만 처리속도가 절차지향에 비해 느리고, 설계에 많은 시간이 들어간다.

객체지향에 3대 특성이 있다.
캡슐화 : 정보은닉의 개념이 포함되어 있고, 속성(필드)과 행위(메서드)를 하나의 클래스라는 캡슐에 묶는 것이다.
다형성 : 하나의 객체가 여러가지 형태를 가질수 있는 것을 의미한다. 오버로딩과 오버라이딩이 있다.
상속 : 상위 클래스의 특성을 하위 클래스가 물려 받는것을 말하고 하위 클래스는 필요한 속성을 확장하여 사용할 수 있다.

추가적으로 추상화가 있다.

추상화 : 추상화는 모델링이며 구첵적인 것을 상세히 하지 않고, 필요성에 의해 특성만 가지고 구성하는것을 말한다.
//---------------------------------------------------------------//.    

[오버로딩 과 오버라이딩]
//---------------------------------------------------------------//.    
오버로딩 : 같은 함수의 이름여러개 정의하는것, 매개변수 타입과 리턴타입등 특징이 다른 여러개의 서브프로그램을 생성하는 것을 말한다.
오버라이딩 : 부모 메소드에서 상속받은 메소드를 자식에서 재정의 하는것이다.
//---------------------------------------------------------------//.    

[OOP]
//---------------------------------------------------------------//.    
Object-Orient Programming의 약자이다.
즉, 객체지향형 프로그래밍을 의미하는데, 모든 데이터를 객체로 취급하여 프로그래밍을 한다.
순차적으로 동작하는 프로그래밍과는 다르게 객체와 객체의 상호작용을 통해 프로그램이 동작한다.
//---------------------------------------------------------------//.    

[객체 와 클래스]
//---------------------------------------------------------------//.    
객체 : 구현해야할 대상으로 식별이 가능한 모든 것이 객체이다.
클래스 : 객체를 만들어 내기 위한 설계도 혹은 틀
         연관되어 있는 변수와 메소드의 집합

객체를 나누는 기준?
객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.

인스턴스?
소프트웨어 세상에 구현된 구체적인 실체로 객체를 소프트웨어 상에 실체화한것이다.
//---------------------------------------------------------------//.    

[자바 동작원리]
//---------------------------------------------------------------//.    
자바로 작성한 코드는 .java의 확장자를 가지고 있다. 자바는 javac라는 컴파일러가 .java로 끝나는 코드를 기계어로 변환한다.
그러면 .java파일이 .class의 파일로 바뀌게 되고 이는 JVM을 통해 실행된다.
//---------------------------------------------------------------//.    

[JVM 특징]
//---------------------------------------------------------------//.    
OS에 구애받지 않고 프로그램을 실행할 수 있게 해준다. 그리고 메모리 관리 기법인 GC를 수행한다.
//---------------------------------------------------------------//.    

[매개변수와 전달인자]
//---------------------------------------------------------------//.    
매개변수 즉, parameter라고 한다.
 -함수를 선언할때 사용된 변수

전달인자 즉, Argument라고 한다.
 - 함수가 호출 되었을때, 함수의 파라미터로 전달될 
//---------------------------------------------------------------//.    

[라이브러리 와 프레임워크]
//---------------------------------------------------------------//.    
라이브러리 : 활용 가능한 도구의 집합을 말한다.
            개발자가 만든 클래스에서 호출하여 사용한다.
프레임워크 : 뼈대, 기반구조로 여러 클래스나 컴포넌트로 구성이 되어있다.
            즉, 특정 문제를 해결하기 위한 클래스와 인터페이스의 집합
            
 차이점: 제어권(흐름)을 누가 가지고 있는지에 대한 차이가 있다.
         라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다쓰지만,
         프레임워크는 전체의 흐름을 스스로 가지고 있으며, 사용자는 그 안에서 코드를 짜 넣는다.
//---------------------------------------------------------------//.    

[동적 프로그래밍]
//---------------------------------------------------------------//.
동적 프로그래밍 : 하나의 문제를 여러개의 작은 문제로 나누어 풀고, 결합하여 해결하는 방식이다.
                 작은 문제가 다른 작은 문제를 해결하는데 사용이 될수 있기 때문에 여러번 계산하는것이 아닌,
                 한번 계산을 하고 난 후, 재황용 하여 메모이제이션 기법으로 속도를 향상 한다.

메모이제이션 : 동일한 계산을 반복해야 할 때, 이전 계산값을 저장하여 동일한 반복 수행을 제거하여
              프로그램 실행 속도를 빠르게 하는 기술이다.
              
동적 프로그래밍의 조건
1. 중복되는 부분 문제가 있어야 한다.
2. 최적 부분 구조
//---------------------------------------------------------------//.

[동일성 과 동등성]
//---------------------------------------------------------------//.
동일성 : 인스턴스가 실제로 같은 인스턴스라는 것을 의미한다. (==)
동등서 : 서로 다르 인스턴스 지만 가지고 있느 값이 같음을 의미한다. (equals)
//---------------------------------------------------------------//.

[length와 length()와 size()]
//---------------------------------------------------------------//.
length 는 배열
length() 문자열 길이
size()는 컬렉션 프레임워크 길이
//---------------------------------------------------------------//.

[클린코드]
//---------------------------------------------------------------//.
코드가 군더더기 없이 깔끔하고, 기능을 수행하는데 있어 적은 라인을 처리가 되어있는 코드.
또한 직접적이고, 에러처리가 잘되어 있으며 하나의 역할을 수행한다.
//---------------------------------------------------------------//.

[c언어와 c++]
//---------------------------------------------------------------//.
C언어는 절차지향이지만 C++은 객체지향 언어이다.
또한 C언어는 같은 이름의 함수가 존재할수 없지만, C++에서는 존재할 수 있다.(오버로딩,오버라이딩)
C는 변수나 함수를 초기에 작성해 줘야하지만 ,C++은 그럴 필요가 없다
//---------------------------------------------------------------//.

[클래스와 구조체]
//---------------------------------------------------------------//.
구조체는 하나로 묶일 수있는 변수(데이터)의 집합이다. 하지만 클래스는 변수와 메서드(함수)의 집합이다.
//---------------------------------------------------------------//.

[컴파일언어와 스크립트언어]
//---------------------------------------------------------------//.
컴파일언어 : c,java,c++,c#..
스크립트언어 : javascript,python..

둘의 차이는 컴파일러가 있는지 없는지에 대한 차이가 있다.
컴파일언어는 한꺼번에 해석을 하지만, 스크립트언어는 실행될때 바로 해석이 된다.
//---------------------------------------------------------------//.

[포인터]
//---------------------------------------------------------------//.
포인터 : 메모리의 주소를 저장하는 변수
쉽게 설명을 하면, 엘레베이터에서 포인터는 해당 층을 가르키는 버튼이라고 생각하면 된다.
포인터를 사용할때, 해당 포인터는 반드시 주소를 가르키고 있어야 한다.
//---------------------------------------------------------------//.

[call by value와 call by reference]
//---------------------------------------------------------------//.
call by value: 주어진 값을 복사하여 전달한다. 해당 함수를 빠져나가게 되면 기존 변수에 영향을 끼치지 않는다.
call by reference : 주소값에 있는 값을 전달한다. 그렇기 때문에 함수를 나가도 값이 변화가 생긴다.
//---------------------------------------------------------------//.

[재귀함수]
//---------------------------------------------------------------//.
재귀함수 : 함수안에서 자기 자신을 호출하는 것을 말한다.

소스코드가 간결해지지만, 연산 시간이 올래걸리고, 잘못 코드를 짜게 되었을때 무한 루프에 빠질수 있다.
//---------------------------------------------------------------//.

[어노테이션]
//---------------------------------------------------------------//.
사전적으로는 주석이라는 의미이지만 JAVA에서는 주석처럼 쓰여 특별한 의미나 기능을 하는 기술이다.
예로) @OVERRIDNG
//---------------------------------------------------------------//.

[제너릭]
//---------------------------------------------------------------//.
제너릭은 타입의 안정성 맡고있다. 컴파일을 하는 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일시에
체크 하기 때문에 객체의 타입의 안정성을 높이고 형변환의 번거로움을 줄인다.
//---------------------------------------------------------------//.

[느슨한 결합 과 강한 결합]
//---------------------------------------------------------------//.
결합도는 의존성을 나타낸다.
즉 모듈이 다른 모듈에 대해 얼만큼의 정보를 알고 있는지에 대한 척도이다.

느슨한 결합은 모듈간 필요한 정보만 알고있다면 두 모듈은 낮은 결합도를 가진다고 한다.
강한 결합은 모듈간 자세한 부분까지 알고있다면 두 모듈은 강한 결합도를 가진다고 한다.

개발시 강한 결합은 피하고 적절한 결합도를 유지하게 해야 한다.
//---------------------------------------------------------------//.

[static]
//---------------------------------------------------------------//.
static은 메모리를 한번 할당하여 프로그램이 종료될때 해제되는 것을 의미한다.
모든 객체가 공유하는 메모리라는 장점이 있지만, 자주 사용하면 시스템 퍼포먼스에 악영향을 주게 된다.
//---------------------------------------------------------------//.

★★★★★자료구조★★★★★  

[자료구조]
//---------------------------------------------------------------//.
*여기서도 실수가 있었다. 많이 긴장을 하고, 빨리 대답을 해야할 거 같은 부담에 힙과 큐를 헷갈려 말했다..
*데크는 생각조차 나지 않았다.

스택 Stack
LIFO구조이다.
PUSH로 넣고, POP으로 꺼낸다.
한쪽으로만 데이터를 넣고 꺼낸다.

큐 Queue
FIFO구조이다.
한방향으로만 데이터를 넣고, 꺼낼수가 있다.(스택과는 다르다.)
Rear에서 Enqueue로 넣고, Front에서 Dequeue로 꺼낸다.

힙 Heap
특정한 규칙을 가지는 트리이다.
트리구조와 배열로 모두 구현 가능하다.
우선사항이 고려된 이진트리 이다.
Root에 가장 큰것을 놓고, 자식 노드에는 작은 것을 놓는다.

덱 Deque
양쪽 방향으로 넣고 꺼낼 수 있다.
스택과 큐의 특성을 모두 가지고 있어 덱을 스택과 큐 모두로 활용할 수 있다.
양방향 연결 리스트로 구현한다.
//---------------------------------------------------------------//.


<<<<<<< HEAD
[백엔드 및 언어공부]
//---------------------------------------------------------------//.`
자바스크립트
=======
[트리 구조]
//---------------------------------------------------------------//.
트리란 그래프의 일종으로 여러개의 노드가 하나의 노드를 가리킬 수 없는 구조이다.
서로 다른 노드를 잇는 길이 하나뿐인 그래프를 트리라고 한다.
//---------------------------------------------------------------//.

[ArrayList 와 LinkedList]
//---------------------------------------------------------------//.
ArrayList : 리스트의 크기가 제한이 되어 있고, 크기 재조정에 많은 연산이 필요하다.
            데이터의 추가 및 삭제시 배열을 생성하여 복제하기 때문에 시간이 오래 걸린다.
            무작위 접근이 가능하다.
            
LinkedList : 리스트의 크기와 상관없이 데이터를 추가 할수 있다.
             추가 및 삭제시 해당 노드를 생성하여 연결하고 삭제하기 때문에 연산이 빠르다.
             무작위로 접근이 불가능하고, 순차적으로 접근을 해야한다.
//---------------------------------------------------------------//.

[list와 set]
//---------------------------------------------------------------//.
list는 중복된 데이터를 저장하고 순서를 유지하는 선형 구조이다.
set은 중복되지 않은 데이터를 저장하고, 순서를 유지하지 않는 선형 자료 구조이다.(treeset은 순서 유지)
//---------------------------------------------------------------//.


[WAS와 WS]    
//---------------------------------------------------------------//.    
WAS는 Web Application service의 약자로 비즈니스 로직을 넣을수 있다. (tomcat등)    
WS는 Web service의 약자로 비즈니스 로직을 넣을수 없다. (Apache등)    

was는 동적인 컨텐츠를 제공하기 위한 어플리케이션 서버이고,
wa는 http를 이용하여 요청을 서비스하는 기능을 담당한다. 

그럼 비즈니스 로직이란?     
로그인을 예로 들었을 경우, 크게 두가지 상황이 발생한다.    
1. 로그인을 하고자 하는 사람에게 [로그인 성공, 로그인 실패, 비밀번호 잘못 되었습니다.]등 안내 문구    
2. DB에서 로그인의 정보를 검색 및 조회 등 활동을 한다.
    
이때 비즈니스 로직은 2번에 해당한다.    
//---------------------------------------------------------------//.    

[컴포넌트와 모듈]    
//---------------------------------------------------------------//.    
컴포넌트 : 실제 동작하는 개체 혹은 독립적인 단위    
모듈 : 구현이 된 단위, 알고리즘 또는 자료구조 등 제공하는 인터페이스    

가장 쉬운 예)
1개의 서버와 20개의 클라이언트가 있을때
모듈은 2개가 되고, 컨포넌트는 21개가 된다.
//---------------------------------------------------------------//.    

[해시 테이블]
//---------------------------------------------------------------//.
해시 테이블은 key와 value로 이루어져 데이터를 저장하는 자료구조로 빠른 데이터 검색이 필요할때 사용한다.
해시테이블은 key값에 해쉬함수를 적용하여 고유한 index를 생성해 해당 index에 저장된 값을 꺼내오는 구조이다.
//---------------------------------------------------------------//.


[다익스트라 알고리즘]
//---------------------------------------------------------------//.
다이나믹 프로그래밍을 이용한 최단경로 탐색 알고리즘이다.
흔히 인공위성 GPS소프트웨어에서 가장 많이 사용한다. 특정하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려주는데, 음의 간선은 포함할 수 없다.
다익스트라 알고리즘이 다이나믹 프로그래밍 문제인 이유는 최단거리는 여러개의 최단 거리로 이루어져 있기 때문이다.
//---------------------------------------------------------------//.

★★★★★운영체제★★★★★    

[프로세스와 스레드]
//---------------------------------------------------------------//.    
프로세스는 실행중인 프로그램.
스레드는 프로세스 내의 독립적으로 실행되는것을 의미한다.
또한
프로세스는 운영체제에게 자원을 할당 받지만, 스레드는 프로세스에 의해 자원을 할당 받는다.

스레드는 적은 메모리를 사용하고, 전역 메모리를 공유한다는 장점이 있지만 교착상태가 발생할수 있다는 단점이 있다.
여기서 멀티 스레드 프로그래밍은 무엇일까?
하나의 프로세스에서 여러개의 스레드를 만들어 자원을 생성및 관리하고 중복을 최소화 한다.
//---------------------------------------------------------------//.    

[동기 및 비동기]
//---------------------------------------------------------------//.    
동기 : 요청을 보낸후 응답을 받아야만 다음 동작이 이루어진다. (블럭)
비동기 : 요청을 보낸후 응답과 상관없이 다음 동작을 한다.     (논블럭)

프로세스 동기화란? 프로세스가 공유 자원을 사용하는 상황에서 공유 자원을 신뢰할수 없기 때문에(경쟁 조건) 이것을 방지하기 위해
                  실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것이다.

//---------------------------------------------------------------//.    

[교착상태]
//---------------------------------------------------------------//.    
교착상태 : 하나이상의 프로세스가 서로 상대방의 작업이 끝나기를 기다리는 상태.

발생조건: 상호배제 : 한 리소스는 하나의 프로세스만 이용할수 있다.
          비선점 : 리소스를 자발적으로 반환하기를 기다린다.(뺏지 않음)
         원형대기 : 프로세스들이 서로를 기다린다.
         점유와대기 : 하나의 프로세스가 리소스를 점유하고 있으면서 다른 리소스를 기다린다.
         
해결방법: 예방 : 발생조건이 만족되지 않게 한다.
         회피 : 발생조건을 없애는 것이 아닌, 알고리즘을 이용하여 해결한다. ex)은행원 알고리즘
         탐지 : 원인을 규명하여 해결한다. ex)자원할당 그래프
         회복 : 교착상태가 발생하면 그 후에 해결하는 방법
//---------------------------------------------------------------//.    


[기아상태]
//---------------------------------------------------------------//.    
기아상태 : 프로세스가 필요한 자원을 할당 받지 못하고 계속 기다리고 있는 상태이다.
//---------------------------------------------------------------//.    

[경쟁상태]
//---------------------------------------------------------------//.    
경쟁상태 : 여러 프로세스가 공유자원에 접근할때 공유 데이터에 대한 실행 순서에 따라 결과가 달라지는 상황이다.
//---------------------------------------------------------------//.    

[임계영역]
//---------------------------------------------------------------//.    
임계영역 : 둘 이상의 프로세스가 동시에 접근하면 안되는 공유 자원(임계영역)에 접근하는 영역(코드 영역)
          즉, 프로그램에서 공유 데이터(임계 자원)를 이용하는 부분이다.
 
문제점: 동시에 접근하게 되면 예상치 못한 결과가 나오게 된다. -> 경쟁상태
//---------------------------------------------------------------//.    

[LRU]
//---------------------------------------------------------------//.    
페이지 교체 알고리즘의 하나로, 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘이다.

페이지 교체 알고리즘을 사용하는 이유는 페이지 부재가 생겼을때 주기억장치에 적재하기 위해 어떤 페이지 프레임을
선택하여 교체할것인지를 정한다.
//---------------------------------------------------------------//.    


[메모리 누수]
//---------------------------------------------------------------//.    
프로그램이 필요없는 메모리를 점유하고 있는 현상이다.
자바의 경우는 GC가 있어 사용하지 않는 객체는 회수하여 메모리 공간을 확보한다.

누수를 막기위해 Local변수로 만들어 자동으로 GC가 되게 만들면 된다.
즉 참조값을 갖는 변수가 최소 유효범위 안에 있도록 하면 된다.
//---------------------------------------------------------------//.    


[도커]
//---------------------------------------------------------------//.    
도커는 컨테이너 기반의 가상화 기술이다.
초기에는 OS를 가상화 하였고, HOST OS위에 GUEST OS를 설치했기 때문에 무겁고 느렸다는 한계가 있었다.
그렇기 때문에 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 도커라는 기술이 등장하였다.

장점: 실행 환경 구축이 쉽고 빠르다.
      공유 환경을 제공한다.
      하드웨어 자원이 절감된다.
단점: 개발 초기의 오버헤드 (도커를 처음 쓰는 개발자일때, 초반 환경 설정시 시행착오가 많음)
      리눅스 친화적이다. (도커를 제대로 쓰기 위해서는 linux기반os에서 사용해야 한다.)
//---------------------------------------------------------------//.    

[프로그램 과 프로세스]
//---------------------------------------------------------------//.    
프로세스란 현재 실행되고 있는 프로그램을 프로세스 라고한다.
그럼 프로그램이 프로세스인가?

프로그램 : 실행 파일로 파일 시스템에 존재하는 실행 파일이다.
프로세스 : 프로그램을 실행시켜주는 주체(인스턴스)
라고 세부적으로 말할수 있다.

대게 프로세스란 위에서 말한대로 -> 실행되고 있는 프로그램이라고 말해도 된다.

하나 예를 들면,
인터넷 창(크롬)을 3개 켰을때, 하나의 크롬(프로그램)을 실행시켜 3개(프로세스)를 만든것이다.
//---------------------------------------------------------------//.    


[JVM]
//---------------------------------------------------------------//.    
JVM은 자바를 실행하기 위한 환경이다.
JVM의 구조를 설명.
1. 프로그램을 실행하기 위해 OS에게 메모리를 할당받는다.
2. 자바 컴파일을 통해 .java 파일을 .class로 변환을 한다.
3. 그후 class loader를 통해 jvm에 로딩을 시킨다.
4. 로딩된 바이트 코드를 execution engine을 통해 기계어로 번역이 된다.
5. 해석이 된 바이트 코드는 runtime data areas에 배치되서 실직적인 수행이 된다.

//---------------------------------------------------------------//.    

[직렬화 와 역직렬화]
//---------------------------------------------------------------//.    
자바에서 입출력은 stream이라는 통로로 데이터가 이동한다. 이때 객체는 바이트형이 아니기 때문에 stream을
저장하거나 네트워크로 전송할 수가 없다. 그래서 객체를 stream을 통해 입출력을 하기 위해 바이트 배열로 변환 하는 과정이 필요한데
이것을 직렬화라고 한다.

반대로 stream을 통해 받은 직렬화된 객체를 다시 원래의 형태로 바꾸는 것을 역직렬화 라고 한다.
//---------------------------------------------------------------//.    

[컨테이너]
//---------------------------------------------------------------//.
컨테이너 : 개발자가 작성한 코드의 처리과정을 위임받은 독립적인 존재다.
적절하게 설정만 되어 있다면 누구의 도움없이 프로그래머가 작성한 코드를 참조한뒤 객체의 생성과 소멸을 컨트롤한다.
//---------------------------------------------------------------//.

[Spring Bean]
//---------------------------------------------------------------//.
loC컨테이너 안에 들어있는 객체로 필요할때 loC컨테이너 에서 가져와서 사용한다.
@Bean을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할수 있다.
//---------------------------------------------------------------//.

[loC와 DI]
//---------------------------------------------------------------//.
loC는 제어의 역전으로 프로그램의 제어의 흐름을 직접 제어하는것이 아니라 외부에서 관리하는 것으로
      코드의 최종 호출은 개발자가 하는 것이 아닌 프레임워크 내부에서 결정한대로 이루어진다.
DI는 의존성 주입은 각 객체간의 의존성을 컨테이너가 자동으로 연결해 주는것으로 개발자가 Bean설정 파일에 
     의존관계가 필요한 정보를 추가하면 컨테이너가 자동으로 연결해준다.
    
//---------------------------------------------------------------//.

[DTO | VO | BO | DAO ]
//---------------------------------------------------------------//.
DTO(Data Transfer Object) : 데이터를 주고받기 위해 사용하는 클래스
VO(Value Object) : 실제 데이터만 저장하는 클래스
BO(Business Object) : DAO를 활용해 비즈니스 로직을 처리하는 클래스로 service에 해당한다.
DAO(Data Acess Object) : DB에 접근하여 실제 데이터를 조회 또는 조작하는 클래스이다. repository또는 Mapper에 해당한다.
//---------------------------------------------------------------//.

[Jquery]
//---------------------------------------------------------------//
자바스크립트 라이브러리로 자바스크립트를 좀더 편하게 쓰기 위한 언어이다.
$ 표시를 이용해 코드를 간단하게 만들수 있다.
//---------------------------------------------------------------//.

[Ajax]
//---------------------------------------------------------------//.
자바스크립트 라이브러리로 비동기식 자바스크립트다.
페이지에서 변화가 생길때 전체를 로드하는 것이아닌, 변한 일부만 로드하는 것을 말한다.
또한 서버와 클라이언트간 Json이나 xml형태로 데이터를 주고 받을 수 있다.
//---------------------------------------------------------------//.

[Json]
//---------------------------------------------------------------//.
자바스크립트의 객체를 만드는 표현식으로 key,value로 이루어져 있다.
//---------------------------------------------------------------//

[DOM]
//---------------------------------------------------------------//.
학습후 채울 예정.
//---------------------------------------------------------------//.


//---------------------------------------------------------------//.
//---------------------------------------------------------------//.


회사에 대한 질문
//---------------------------------------------------------------//.   
1. 현업에서는 어떤 툴이나 기술을 이용하는지 알고싶다.
2. TDD(Test Driven Development)나 BDD(Behavior-Driven Development) 또는 DDD(Domian-Driven Development)를 사용하는가?
3. 요즘 해당 팀에서 관심있게 생각하는 기술이나 스킬은 무엇인가?
4. 회사내의 스터디나 세미나 같은 것이 있는가?
//---------------------------------------------------------------//.    

알아볼것.
//---------------------------------------------------------------//.    
젠킨스랑 깃허브 차이 -> 깃허브를 쓰면되는거 아닌가? 왜 둘다 쓰거나 젠킨스만 사용하는가?
//---------------------------------------------------------------//.    

>>>>>>> 6934decd2a3ce8e85e646fbb96182d62085a4b8e

